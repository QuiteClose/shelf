##############################################################
# shelf.sh
# Useful shell functions (source from ~/.zshrc)
##############################################################

# This file is auto-generated by build.sh. DO NOT EDIT!

##############################################################
# changedir.sh
# Used by other shelf utils to change working-directory.
##############################################################

changedir() {
  # Change the current working-directory to the given path
  # posts a message to stderr about the change.
  local TARGET="$1"
  if [[ -z "${TARGET}" ]]; then
    TARGET="${HOME}"
  fi
  TARGET="$(realpath -m "${TARGET}")"
  echo "${PWD} ï¡ ${TARGET}" | sed "s|${HOME}|~|g"
  cd "${TARGET}"
}
##############################################################
# git.sh
# Little git helpers.
##############################################################

function git-go() {
	# goto root directory of the .git project
	if [ -d ".git" ]; then
		echo ".git already exists in the current working-directory."
		return 1
	fi
	local PARENT=".."
	local SEARCH="$PARENT"
	while true; do
		if [ -d "$SEARCH/.git" ]; then
			echo "$PWD"
			cd $SEARCH
			return 0
		elif [ "$(realpath $SEARCH)" = "/" ]; then
			echo "No parent .git project."
			return 1
		else
			SEARCH="$PARENT/$SEARCH"
		fi
	done
}

function git-scrub() {
	# scrub (delete) merged branches
	local CURRENT_BRANCH=$(git branch --show-current)
	if [ $CURRENT_BRANCH != "main" && $CURRENT_BRANCH != "master" ]; then
		echo "Must be on main or master branch to git-scrub!"
		return 1
	fi
	for branch in $(git branch --merged HEAD|grep -vw $CURRENT_BRANCH); do
		git branch -d $branch
	done
}
##############################################################
# kubectl.sh
# Common kubectl shortcuts
##############################################################

alias k='kubectl'

##############################################################
# python.sh
# venv etc.
##############################################################

activate='source ./venv/bin/activate'

##############################################################
# repo.sh
# Quickly clone/search/switch-to repo directories.
##############################################################

REPO_ROOT="$(realpath ~/repos)"
REPO_STAT="%Y %W %n"
REPO_LIST="$REPO_ROOT/_manifest.txt"
REPO_HOST="_server.txt"

repo_git_all() {
  find "${REPO_ROOT}" -mindepth 4 -maxdepth 4 -type d -name .git -printf "%p "
}

repo_init() {
  if [[ ! -d "${REPO_ROOT}" ]]; then mkdir -p "${REPO_ROOT}"; fi
  if [[ ! -f "${REPO_LIST}" ]];  then  repo_git_all | xargs -- stat -c "${REPO_STAT}" | sed "s|${REPO_ROOT}/||;s|/\.git\$||" > "${REPO_LIST}"; fi
}

repo_reset() {
  if [[ -f "${REPO_LIST}" ]];  then
    >&2 echo "Resetting ${REPO_LIST}"
    rm -f "${REPO_LIST}"
  fi
  repo_init
}

repo_stat() {
  local SELECT="$1"
  stat -c "${REPO_STAT}" "${REPO_ROOT}/${SELECT}/.git"| sed "s|${REPO_ROOT}/||;s|/\.git\$||"
}

repo_usage() {
  >&2 echo "Usage: repo [-c <URL> | -s | [-d|-r] <TERMS...>]
  Searches cloned repositories for given TERMS and changes-dir to the match.
  repositories. More terms can be added to narrow down the search. Changes
  directory to the matching repository if only one match is found.

  -b, --browse Scroll through all cloned repositories (or a specific remote).
  --clone      Clone a repository with the given terms.
  -c           Sort by git clone date.
  -d           Sort by repo selection history.
  -g           Sort by git activity date.

  If no terms are given, switches to most recently-accessed repo."
}

repo() {
  repo_init
  local GIT_URI_REGEX='^git@[A-Za-z0-9_.-]+(:[0-9]+)?:[A-Za-z0-9_.\/-]+\.git$'
  local GIT_HTTP_REGEX='^https?://[A-Za-z0-9_.-]+(/[A-Za-z0-9_.\/-]+)?\.git$'
  local ACTION="search" # What to do
  local ORDER="name"    # Sort order
  local REMOTE=""       # Name of server, e.g. github for github.com
  local SEARCH=""       # Search terms to select repos. 
  local FILTER=""       # Filter used by grep (built from SEARCH)
  local MATCHES=""      # Repos that matches the filter
  local COUNT=""        # Number of matches
  local SORTER="sort"   # sort command
  local FIELDS="-nk3,3" # sort command flags
  local GITURI=""       # Git URI, e.g. git@github.com:quiteclose/shelf.git
  local SERVER=""       # First part of URI, e.g. git@github.com
  local SELECT=""       # Selects repos on the server, e.g. quiteclose/shelf
  case "$1" in
    -h|--help)   repo_usage; return 0 ;;
    -b|--browse) ACTION="browse"; REMOTE="$2"; ;;
    --clone)     ACTION="clone";  REMOTE="$2"; SEARCH="$3" ;;
    -c) ORDER="clone";    shift 1; SEARCH="$*" ;;
    -d) ORDER="history";  shift 1; SEARCH="$*" ;;
    -g) ORDER="activity"; shift 1; SEARCH="$*" ;;
    -n) ORDER="name";     shift 1; SEARCH="$*" ;;
    *)  SEARCH="$*" ;;
  esac
  case "${ACTION}" in
    browse)
      if [[ -z "${REMOTE}" ]]; then
        tree -dL3 "${REPO_ROOT}" | less
        return $?
      elif [[ -d "${REPO_ROOT}/${REMOTE}" ]]; then
        tree -dL2 "${REPO_ROOT}/${REMOTE}" | less
        return $?
      else
        >&2 echo "Remote ${REMOTE} is not one of the known remotes:" 
        tree -dL1 "${REPO_ROOT}"
        return 1
      fi
      ;;
    clone)
      if [[ -z "${SEARCH}" ]]; then
        # Only REMOTE given, so expect that to be a git@ URI
        GITURI="${REMOTE}"
        if [[ "${GITURI}" =~ $GIT_URI_REGEX ]]; then
          # Get URI fields, e.g.  # git@github.com:quiteclose/shelf.git
          SEARCH="${GITURI##*:}"  #                quiteclose/shelf.git
          SEARCH="${SEARCH%.git}" #                quiteclose/shelf
          SERVER="${GITURI%:*}"   # git@github.com
          SERVER="${SERVER#git@}" #     github.com
        elif [[ "${GITURI}" =~ $GIT_HTTP_REGEX ]]; then
          # Get URI fields, e.g.  # https://github.com/quiteclose/shelf.git
          SERVER="${GITURI#*://}" #         github.com/quiteclose/shelf.git
          SERVER="${SERVER%%/*}"  #         github.com
          SEARCH="${GITURI#*://}" #         github.com/quiteclose/shelf.git
          SEARCH="${SEARCH#*/}"   #                    quiteclose/shelf.git
          SEARCH="${SEARCH%.git}" #                    quiteclose/shelf
        else
          >&2 echo "Either provide a git@ URI, an HTTPS URL or <remote> <name>/<repo>"
          return 1
        fi
        # Find the remote that matches the server
        REMOTE=""
        for name in "${REPO_ROOT}"/*; do
          if [[ ! -d "${name}" || ! -f "${name}/${REPO_HOST}" ]]; then continue; fi
          name="$(basename "${name}")"
          if [[ "${SERVER}" = "$(cat "${REPO_ROOT}/${name}/${REPO_HOST}")" ]]; then
            REMOTE="${name}"
            break
          fi
        done
        # Create the remote if it does not exist
        if [[ -z "${REMOTE}" ]]; then
          >&2 echo "Remote not found for ${SERVER}"
          REMOTE="${REMOTE%%[^a-zA-Z0-9:]*}" # Isolate leading alnum
          if [[ -z "${REMOTE}" ]]; then
            >&2 echo "Remote name is empty. Cannot create remote."
            return 1
          elif [[ -d "${REPO_ROOT}/${REMOTE}" ]]; then
            >&2 echo "Remote ${REMOTE} already exists."
            return 1
          fi
          >&2 echo "Creating remote ${REMOTE} for ${SERVER}"
          mkdir -p "${REPO_ROOT}/${REMOTE}"
          echo "${SERVER}" > "${REPO_ROOT}/${REMOTE}/${REPO_HOST}"
        fi
      fi
      # REMOTE and SEARCH are now set (and the remote should exist)
      if [[ ! -d "${REPO_ROOT}/${REMOTE}" ]]; then
        >&2 echo "Remote ${REMOTE} does not exist. Try cloning a full git@ URI."
        return 1
      fi
      if [[ ! -f "${REPO_ROOT}/${REMOTE}/${REPO_HOST}" ]]; then
        >&2 echo "Remote ${REMOTE} does not have a ${REPO_HOST} file."
        return 1
      fi
      if [[ -e "${REPO_ROOT}/${REMOTE}/${SEARCH}" ]]; then
        >&2 echo "${SEARCH} already exists at ${REPO_ROOT}/${REMOTE}/${SEARCH}"
        return 1
      fi
      # Clone the repository
      SERVER="$(cat "${REPO_ROOT}/${REMOTE}/${REPO_HOST}")"
      SELECT="${REMOTE}/${SEARCH}"
      mkdir -p "$(dirname "${REPO_ROOT}/${SELECT}")"
      git clone "${GITURI}" "${REPO_ROOT}/${SELECT}"
      ;;
    search)
      # search for matching repo
      FILTER="$(echo "${SEARCH}"|sed 's/ /\\\|/g')"
      if [[ "${ORDER}" = "activity" ]]; then FIELDS="-nk1,3"; fi
      if [[ "${ORDER}" = "clone" ]];    then FIELDS="-nk2,3"; fi
      if [[ "${ORDER}" = "history" ]];  then FIELDS=""; SORTER="cat"; fi
      if [[ "${ORDER}" = "name" ]];     then FIELDS="-k3"; fi
      MATCHES="$(${SORTER} ${FIELDS} "${REPO_LIST}" | awk '{print $NF}')"
      while [[ -n "$1" && -n "${MATCHES}" ]]; do
        MATCHES="$(echo "${MATCHES}" | grep -i "$1")"
        shift 1
      done
      if [[ -z "${SEARCH}" ]]; then
        SELECT="$(echo "${MATCHES}" | tail -n1 | xargs)"
        if [[ -z "${SELECT}" ]]; then
          >&2 echo "Unexpected: No repositories found?"
          repo_reset
          return 1
        fi
      else
        COUNT="$(echo "${MATCHES}" | wc -l | xargs)"
        if [[ "${COUNT}" -eq 1 ]]; then
          SELECT="$(echo "${MATCHES}" | head -n1 | xargs)"
        else
          >&2 echo "Found ${COUNT} matching repositories:"
          echo "${MATCHES}" | sed 's/^/  /' | grep -i --color "${FILTER}"
        fi
      fi
      ;;
  esac
  if [[ -n "${SELECT}" ]]; then
    local MATCH="$(grep -m1 -w "${SELECT}" "${REPO_LIST}")"
    if [[ -n "${MATCH}" ]]; then
      local OTHERS="$(grep -vw "${SELECT}" "${REPO_LIST}")"
      {echo "${OTHERS}"; echo "${MATCH}"} > "${REPO_LIST}"
    else
      repo_stat "${SELECT}" >> "${REPO_LIST}"
    fi
    changedir "${REPO_ROOT}/${SELECT}"
  fi
  return 0
}
##############################################################
# shoes.sh
# Manages a common token file and cluster login files. Source
# the token with -t, edit it with -e. Name a cluster to source
# a matching cluster file. If multiple cluster files match,
# falls-back to searching for the given name. You can force
# this search-behaviour with -s if you don't want to login.
# When naming a cluster, use -e and -c to create a new cluster
# file with the given name.
##############################################################

function shoes() {
	local SHOES_PATH="$HOME/.local/share/shoes"
	local ACTION=""
	local CLUSTER=""
	mkdir -p $SHOES_PATH{,/cluster}
	case $1 in
	-c|--create)
		ACTION="create"
		CLUSTER="$2"
		;;
	-e|--edit)
		ACTION="edit"
		CLUSTER="$2"
		;;
	-h|--help)
		ACTION="help"
		;;
	-s|--search)
		ACTION="search"
		CLUSTER="$2"
		;;
	-t|--token)
		ACTION="token"
		CLUSTER="$2"
		;;
	*)
		ACTION="login"
		CLUSTER="$1"
		;;
	esac
	case $ACTION in
	help)
		echo "Usage: shoes [OPTIONS] <CLUSTER>"
		echo "  Login to a cluster with a saved token. If no single cluster-file"
		echo "  matches the given name, list all matches. Non-login action are"
		echo "  triggered via options:"
		echo 
		echo "  -c, --create     Create a cluster-file with the given name."
		echo "  -e, --edit       Edit the token (or cluster-file if given.)"
		echo "  -h, --help       Display this help message."
		echo "  -r, --rename     Rename a cluster file."
		echo "  -s, --search     List matching cluster files."
		echo "  -t, --token      Source the token."
		return 0
		;;
	create)
		if [ -z "$CLUSTER" ]; then
			>&2 echo "Name a cluster to create."
			return 1
		fi
		if [ -e "$SHOES_PATH/cluster/$CLUSTER.sh" ]; then
			>&2 echo "Cluster file already exists at $SHOES_PATH/cluster/$CLUSTER.sh"
			return 1
		fi
		>&2 echo "Editing cluster file at $SHOES_PATH/cluster/$CLUSTER.sh"
		vi "$SHOES_PATH/cluster/$CLUSTER.sh"
		return $?
		;;
	edit)
		if [ -n "$CLUSTER" ]; then
			if [ -e "$SHOES_PATH/cluster/$CLUSTER.sh" ]; then
				>&2 echo "Editing cluster file at $SHOES_PATH/cluster/$CLUSTER.sh"
				vi "$SHOES_PATH/cluster/$CLUSTER.sh"
				return $?
			fi
			>&2 echo "Cluster file does not exist at $SHOES_PATH/cluster/$CLUSTER.sh"
			return 1
		fi
		>&2 echo -n "Backing up token: "
		cp -v "$SHOES_PATH/_token.txt" "$SHOES_PATH/_token.txt.bak"
		>&2 echo "Editing token at $SHOES_PATH/_token.txt"
		>&2 echo "If you want to source the token, run:"
		>&2 echo "  shoes -t"
		vi "$SHOES_PATH/_token.txt"
		return $?
		;;
	token)
		if [ -n "$CLUSTER" ]; then
			>&2 echo "Error: Do not specify a cluster when sourcing the token."
			return 1
		fi
		>&2 echo "Sourcing token from $SHOES_PATH/_token.txt"
		export VAULT_TOKEN=$(cat "$SHOES_PATH/_token.txt")
		return 0
		;;
	login)
		if [ -z "$CLUSTER" ]; then
			>&2 echo "Name a cluster to search for."
			return 1
		fi
		if [ -e "$SHOES_PATH/cluster/$CLUSTER.sh" ]; then
			>&2 echo "Sourcing cluster file at $SHOES_PATH/cluster/$CLUSTER.sh"
			source "$SHOES_PATH/cluster/$CLUSTER.sh"
			return $?
		fi
		;& # fall-through if no cluster file matches exactly
	search)
		if [ -z "$CLUSTER" ]; then
			CLUSTER=".*"
		fi
		local CLUSTER_LIST="$(ls $SHOES_PATH/cluster|grep -v ^_|awk -F. '{print $1}'|sort)"
		local MATCHES=$(grep $CLUSTER <<< $CLUSTER_LIST)
		local LENGTH=$(wc -l <<< $MATCHES|xargs)
		if [ "$MATCHES" = "" ]; then
			>&2 echo "Found 0 clusters matching \"$CLUSTER\""
			return 1
		elif [ "$LENGTH" -gt 1 ]; then
			ACTION="search"
		fi
		if [ "$ACTION" = "search" ]; then
			>&2 echo "Found $LENGTH matching clusters:"
			sed 's/^/  /' <<< $MATCHES|grep --color $CLUSTER
			return 0
		else
			>&2 echo "Sourcing cluster file at $SHOES_PATH/cluster/$MATCHES.sh"
			source "$SHOES_PATH/cluster/$MATCHES.sh"
		fi
		;;
	esac
}
##############################################################
# tempdir.sh
# Quickly create/search/switch-to temporary directories.
##############################################################

tempdir_usage() {
  >&2 echo "Usage: tempdir -c | -p | [<SORT>] [<TERMS...>] [--browse]
  Creates & searches tempdirs. Changes to that directory when only one matches.

  -c           Create a tempdir (optionally with a <LABEL>)
  -p, --prune  Delete unused tempdirs.
  -b, --browse Do not changedir.
  -t, --tree   View the tempdirs as a tree.

  SORT options (upper-case reverses the sort):
  -d,-D        Sort by tempdir selection history.
  -f,-F        Sort by file-name.
  -n,-N        Sort by name.

  TERMS:       A series of filters that apply successively to previous results.

               Find expressions start with a dash (-) (or ! for negation) and
               are applied to each matching tempdir. They generate output that
               can be filtered or browsed. Find expressions come in a series of
               key-value pairs, and are passed directly to the find command.
               Note that only the following find expressions are allowed:
                 -ctime
                 -maxdepth
                 -mindepth
                 -mtime
                 -name
                 -type

               Grep filters are terms that DO NOT start with a dash. They are
               fed the input of the previous find command (or grep.) Successive
               grep filters reduce the results. You can generate more results
               by issuing a find expression on the current-matches.

               Note that if the 1st term is a grep filter, a default find
               command will be used to seed the initial search.
"
}

TEMPDIR_ROOT="$(realpath -m ~/tempdirs)"
TEMPDIR_LIST="${TEMPDIR_ROOT}/_manifest.txt"
TEMPDIR_FIND_PREFIX=( \
  \( \
    -name .git -o -name .github -o -name node_modules -o -name venv -o -name .venv \
    -o -name dist -o -name build -o -name out -o -name target -o -name __pycache__ \
    -o -name .idea -o -name .vscode -o -name .tox -o -name .eggs -o -name .cache \
    -o -name .mypy_cache -o -name .pytest_cache -o -name .egg-info \
    -o -name .DS_Store -o -name .directory -o -name .project -o -name .classpath \
    -o -name .settings -o -name .gitignore -o -name .gitattributes -o -name .gitmodules \
    -o -name .hg -o -name .hgignore -o -name .hgrc -o -name .svn -o -name .bzr \
    -o -name LICENSE -o -name COPYING -o -name README.md -o -name CHANGELOG.md \
  \) \
  -prune -o \
)
TEMPDIR_FIND_SUFFIX=(-print)

tempdir_all() {
  find "${TEMPDIR_ROOT}" -mindepth 1 -maxdepth 1 -type d "${TEMPDIR_FIND_SUFFIX[@]}" | sed "s|${TEMPDIR_ROOT}/||"
}

tempdir_create() {
  tempdir_init
  local STAMP="$(date '+%y%m%d')"
  mktemp -d -p "${TEMPDIR_ROOT}" "${STAMP}.XXXXXX" | sed "s|^${TEMPDIR_ROOT}/||" | tee -a "${TEMPDIR_LIST}"
}


tempdir_init() {
  if [[ ! -d "${TEMPDIR_ROOT}" ]]; then mkdir -p "${TEMPDIR_ROOT}"; fi
  if [[ ! -f "${TEMPDIR_LIST}" ]];  then  tempdir_all | sort -n > "${TEMPDIR_LIST}"; fi
}

tempdir_reset() {
  if [[ -f "${TEMPDIR_LIST}" ]];  then
    >&2 echo "Resetting ${TEMPDIR_LIST}"
    rm -f "${TEMPDIR_LIST}"
  fi
  tempdir_init
}

tempdir_sort_by_filename() {
  # Sorts input lines (tempdirs) by their file name.
  awk -F/ '{print $NF, $0}' | sort | cut -d' ' -f2-
}

tempdir_sort_by_history() {
  # Sorts input lines (tempdirs) by their history in TEMPDIR_LIST.
  awk -F/ '
    NR==FNR { o[$1]=++n; next }
    { key=$1; print (o[key] ? o[key] : 999999), $0 }
  ' <(tac "${TEMPDIR_LIST}") - | sort -n | cut -d' ' -f2-
}

tempdir_sort_by_name() {
  # Sorts input lines numerically by timestamp prefix (assumes it's at the start).
  sort "${1:-/dev/stdin}"
}


tempdir_reverse_by_filename() {
  tempdir_sort_by_filename | tac
}

tempdir_reverse_by_history() {
  tempdir_sort_by_history | tac
}

tempdir_reverse_by_name() {
  # Sorts input lines numerically by timestamp prefix (assumes it's at the start).
  tac "${1:-/dev/stdin}"
}

tempdir() {
  tempdir_init
  case "$1" in
    -c|--create) changedir "${TEMPDIR_ROOT}/$(tempdir_create)"; return $?;;
    -p|--prune)  tempdir_prune; return $?;;
    -h|--help)   tempdir_usage; return 0;;
  esac
  local ACTION="seek"     # either "seek" or "browse"
  local RENDER="list"     # either "list" or "tree"
  local GIVEN_ARGS=()     # because we consume them as we iterate
  local TERM_SORT="-d"    # either -d, -f, or -n
  local TERMS=()          # search terms
  local RESULTS=""        # full search results
  local MATCHES=""        # tempdirs that match the search
  local COUNT=0           # number of matches
  local SORTER=()         # sort command
  local SELECT=""         # which tempdir to navigate to
  local FIND_GLOBAL=()    # global find options
  local FIND_EXPR=()      # find expression options
  local GREP_PREFIX=(-iE) # grep options
  local TREE_PREFIX=(-L3) # tree options
  local HISTORY_MATCH=""  # single selection history line
  local HISTORY_ALL=""    # all tempdir selection history
  if [[ "$1" =~ ^-(d|f|n|D|F|N)$ ]]; then
    TERM_SORT="$1";
    shift;
  fi
  case "${TERM_SORT}" in
    -d)   SORTER=tempdir_sort_by_history;;
    -f)   SORTER=tempdir_sort_by_filename;;
    -n)   SORTER=tempdir_sort_by_name;;
    -D)   SORTER=tempdir_reverse_by_history;;
    -F)   SORTER=tempdir_reverse_by_filename;;
    -N)   SORTER=tempdir_reverse_by_name;;
  esac
  MATCHES="$(tempdir_all)"
  if [ -z "${MATCHES}" ]; then
    >&2 echo "No tempdirs found."
    return 1
  fi
  GIVEN_ARGS=("$@")
  if [ -z "${GIVEN_ARGS[*]}" ]; then
    # No args, so just sort tempdirs
    MATCHES="$(echo "${MATCHES}" | $SORTER)"
  elif [[ ! "$1" =~ ^-[^-] && ! "$1" == "!" ]]; then
    # No find expression, so seed results for grep
    FIND_GLOBAL=(-mindepth 0 -maxdepth 2)
    RESULTS="$(echo "${MATCHES}" | sed "s|^|${TEMPDIR_ROOT}/|" | xargs -d '\n' -I{} find {} "${FIND_GLOBAL[@]}" "${TEMPDIR_FIND_PREFIX[@]}" "${FIND_EXPR[@]}" "${TEMPDIR_FIND_SUFFIX[@]}" | sed "s|${TEMPDIR_ROOT}/||" | $SORTER )"
  fi
  # Build & apply filters from command-line arguments
  while [ -n "$1"  ]; do
    case "$1" in
      -b|--browse) ACTION="browse"; shift 1; continue;;
      -t|--tree)   RENDER="tree";   shift 1; continue;;
    esac
    if [[ "$1" =~ ^-[^-] || "$1" == "!" ]]; then
      # consume find expression
      FIND_GLOBAL=()
      FIND_EXPR=()
      while [[ "$1" =~ ^-[^-] || "$1" == "!" ]]; do
        if [[ "$1" == "-name" ]]; then
          TERMS+=("$(echo "$2" | sed 's|*|.*|g;s|?|.|g')")
        fi
        case "$1" in
          -maxdepth|-mindepth)
            FIND_GLOBAL+=("$1" "$2"); shift 2;;
          -ctime|-mtime|-name|-type)
            FIND_EXPR+=("$1" "$2"); shift 2;;
          -o|-or|-a|-and|!|-not)
            FIND_EXPR+=("$1"); shift 1;;
          *) >&2 echo "Blocked find option: $1"; return 1;;
        esac
      done
      TERMS+=("/")
      RESULTS="$(echo "${MATCHES}" | sed "s|^|${TEMPDIR_ROOT}/|" | xargs -d '\n' -I{} find {} "${FIND_GLOBAL[@]}" "${TEMPDIR_FIND_PREFIX[@]}" "${FIND_EXPR[@]}" "${TEMPDIR_FIND_SUFFIX[@]}" | sed "s|${TEMPDIR_ROOT}/||" | $SORTER )"
    else
      # consume grep filter
      TERMS+=("$1")
      RESULTS="$(echo "${RESULTS}" | grep ${GREP_PREFIX[@]} "$1" | $SORTER )"
      shift 1
    fi
    MATCHES="$(echo "${RESULTS}" | sed "s/\/.*//" | awk '!seen[$0]++' )"
  done
  if [ ${#GIVEN_ARGS[@]} -eq 0 ]; then
    # No args, so user expects to changedir
    SELECT="$(echo "${MATCHES}" | head -n1 | xargs)"
    if [ -z "${SELECT}" ]; then
      >&2 echo "Unexpected: No tempdirs found?"
      tempdir_reset
      return 1
    fi
  else
    # Args given, so maybe we must render results
    if [ -t 1 ]; then 
      GREP_PREFIX+=(--color=always)
    fi
    COUNT="$(echo "${MATCHES}" | wc -l | xargs)"
    if [ "$COUNT" -eq 1 ] && [ "$ACTION" != "browse" ]; then
      SELECT="$(echo "${MATCHES}" | head -n1 | xargs)"
    elif [ "${RENDER}" = "tree" ]; then
      echo "${MATCHES}" | sed "s|^|${TEMPDIR_ROOT}/|" | xargs -d '\n' -- tree --noreport $TREE_PREFIX | grep ${GREP_PREFIX[@]} "^|$(IFS="|"; echo "${TERMS[*]}")" | less -RF
    elif [ "${RENDER}" = "list" ]; then
      >&2 echo "Found ${COUNT} matching tempdirs."
      echo "${RESULTS}" | sed "s|^${TEMPDIR_ROOT}/|  |" | grep ${GREP_PREFIX[@]} "^|$(IFS="|"; echo "${TERMS[*]}")" | less -RF
    fi
  fi
  if [ -n "${SELECT}" ] && [ "${ACTION}" = "seek" ]; then
    # trim TEMPDIR_ROOT and trailing slash
    SELECT="$(echo "${SELECT}" | sed "s|^${TEMPDIR_ROOT}/||;s|/$||")"
    HISTORY_MATCH="$(grep -wm1 "${SELECT}" "${TEMPDIR_LIST}")"
    if [ -n "${HISTORY_MATCH}" ]; then
      # If the tempdir is already in the history, remove it first
      HISTORY_ALL="$(grep -vw "${SELECT}" "${TEMPDIR_LIST}")"
      {echo "${HISTORY_ALL}"; echo "${HISTORY_MATCH}"} > "${TEMPDIR_LIST}"
    else
      # Otherwise, append it to the history
      echo "${SELECT}" >> "${TEMPDIR_LIST}"
    fi
    changedir "${TEMPDIR_ROOT}/${SELECT}"
  fi
  return 0
}
##############################################################
# timestamp.sh
# Records lines of text along with a timestamp. Use with a -
# to add a note to the last timestamp, or with --all to see
# with notes.
##############################################################

function ts() {
	local STAMP="$(date -u '+%y%m%d.%H%MZ')"
	local TXT="timestamps.txt"
	if [ -z "$1" ]; then
		if [ -e $TXT ]; then
			grep --color '^\d\S*' <(cat $TXT; echo "$STAMP <<< Current time.")
		else
			echo "$STAMP <<< Current time."|grep --color '^\S*' 
		fi
	elif [[ "$@" = "--help" ]]; then
		echo "Usage: ts [OPTIONS] [MESSAGE]"
		echo "Record a message to timestamps.txt along with a timestamp."
		echo 
		echo "  -                Add a note to the last timestamp."
		echo "  --all            Show all timestamps with notes."
		echo
	elif [[ "$@" = "--all" ]]; then
		grep --color '^\S*' <(cat $TXT; echo "$STAMP <<< Current time.")
	elif [[ "$@" = "-" ]]; then
		grep '^\d' $TXT|tail -n1|grep --color '^\S*'
		echo "Enter notes:"|grep --color '.*'
		sed 's/^/  /' >> $TXT
		echo "Use \"ts --all\" to see notes."|grep --color '.*'
	else
		echo "$STAMP $@"|tee -a $TXT|grep --color '^\S*'
	fi
}

function tsl() {
	ts|sed 's/Z/+0000/'|while read line; do
		local GIVEN_STAMP="$(awk '{print $1}' <<< $line)"
		local CONVERTED_STAMP="$(date -j -f '%y%m%d.%H%M%z' $GIVEN_STAMP '+%y%m%d.%H%M%z')"
		sed "s/$GIVEN_STAMP/$CONVERTED_STAMP/" <<< $line
	done|grep --color '^\S*'
}

##############################################################
# workspace.sh
# Quickly create/search/switch-to project directories. Run
# with any term to search existing workspaces (or to switch to
# that workspace if only one is matched.) Use -d to sort by
# timestamp or -c to create a new workspace.
##############################################################

function workspace() {
    local WORKSPACE_ROOT=~/workspaces
    local ACTION=""
    local ORDER="name"
    local LABEL=""
    case $1 in
        -c|--create)
            ACTION="create"
            LABEL="$2"
            ;;
        -h|--help)
            ACTION="help"
            ;;
        -d|--date)
            ORDER="date"
            ACTION="goto"
            LABEL="$2"
            ;;
        *)
            ACTION="goto"
            LABEL="$1"
            ;;
    esac
    case $ACTION in
        help)
            echo "Usage: workspace [OPTIONS] <LABEL>"
            echo "Switch to a workspace with the given label. Or, if an option is given:"
            echo
            echo "  -c, --create     Create a workspace with the given label."
            echo "  -h, --help       Display this help message."
			echo
			echo "If no argument is given, switch to the latest workspace."
            return 0
        ;;
        create)
            if [ -z "$LABEL" ]; then
                >&2 echo "Provide a label to create a workspace."
                return 1
            fi
            local TIMESTAMP="$(date '+%y%m%d')"
            local WORKSPACE_PATH="$WORKSPACE_ROOT/$LABEL.$TIMESTAMP"
            if [ -e "$WORKSPACE_PATH" ]; then
                >&2 echo "Workspace already exists at $WORKSPACE_PATH"
                return 1
            fi
            >&2 mkdir -p "$WORKSPACE_PATH"
            >&2 echo "Leaving $PWD"
            cd "$WORKSPACE_PATH"
            return $?
        ;;
        *)
            if [ -z "$LABEL" ]; then
                >&2 echo "Leaving $PWD"
                cd $(ls -td ~/workspaces/*|head -n1)
                return 0
            fi
            local WORKSPACES=$(ls -td $WORKSPACE_ROOT/*|awk -F/ '{print $NF}')
            if [ "$ORDER" = "date" ]; then
                local WORKSPACE_LIST=$(awk -F. '{print $2,$0}'<<<$WORKSPACES|sort -n|awk '{print $2}')
            else
                local WORKSPACE_LIST=$(sort<<<$WORKSPACES)
            fi
            if ! grep -q $LABEL <<< $WORKSPACE_LIST; then
                >&2 echo "Found 0 workspaces matching \"$LABEL\""
                return 1
            else
                local MATCHES=$(grep --color $LABEL <<< $WORKSPACE_LIST)
                if [ $(wc -l <<< $MATCHES|xargs) -eq 1 ]; then
                    >&2 echo "Leaving $PWD"
                    cd "$WORKSPACE_ROOT/$MATCHES"
                else
                    >&2 echo "Found $(wc -l <<< $MATCHES|xargs) matching workspaces:"
                    sed 's/^/  /' <<< $MATCHES|grep --color $LABEL
                    return 1
                fi
            fi
            return $?
        ;;
    esac
}
