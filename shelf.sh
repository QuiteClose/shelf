##############################################################
# shelf.sh
# Useful shell functions (source from ~/.zshrc)
##############################################################

# This file is auto-generated by build.sh. DO NOT EDIT!

##############################################################
# git.sh
# Little git helpers.
##############################################################

function git-go() {
	# goto root directory of the .git project
	if [ -d ".git" ]; then
		echo ".git already exists in the current working-directory."
		return 1
	fi
	local PARENT=".."
	local SEARCH="$PARENT"
	while true; do
		if [ -d "$SEARCH/.git" ]; then
			echo "$PWD"
			cd $SEARCH
			return 0
		elif [ "$(realpath $SEARCH)" = "/" ]; then
			echo "No parent .git project."
			return 1
		else
			SEARCH="$PARENT/$SEARCH"
		fi
	done
}

function git-scrub() {
	# scrub (delete) merged branches
	local CURRENT_BRANCH=$(git branch --show-current)
	if [ $CURRENT_BRANCH != "main" && $CURRENT_BRANCH != "master" ]; then
		echo "Must be on main or master branch to git-scrub!"
		return 1
	fi
	for branch in $(git branch --merged HEAD|grep -vw $CURRENT_BRANCH); do
		git branch -d $branch
	done
}
##############################################################
# kubectl.sh
# Common kubectl shortcuts
##############################################################

alias k='kubectl'

##############################################################
# python.sh
# venv etc.
##############################################################

activate='source ./venv/bin/activate'

##############################################################
# shoes.sh
# Manages a common token file and cluster login files. Source
# the token with -t, edit it with -e. Name a cluster to source
# a matching cluster file. If multiple cluster files match,
# falls-back to searching for the given name. You can force
# this search-behaviour with -s if you don't want to login.
# When naming a cluster, use -e and -c to create a new cluster
# file with the given name.
##############################################################

function shoes() {
	local SHOES_PATH="$HOME/.local/share/shoes"
	local ACTION=""
	local CLUSTER=""
	mkdir -p $SHOES_PATH{,/cluster}
	case $1 in
	-c|--create)
		ACTION="create"
		CLUSTER="$2"
		;;
	-e|--edit)
		ACTION="edit"
		CLUSTER="$2"
		;;
	-h|--help)
		ACTION="help"
		;;
	-s|--search)
		ACTION="search"
		CLUSTER="$2"
		;;
	-t|--token)
		ACTION="token"
		CLUSTER="$2"
		;;
	*)
		ACTION="login"
		CLUSTER="$1"
		;;
	esac
	case $ACTION in
	help)
		echo "Usage: shoes [OPTIONS] <CLUSTER>"
		echo "  Login to a cluster with a saved token. If no single cluster-file"
		echo "  matches the given name, list all matches. Non-login action are"
		echo "  triggered via options:"
		echo 
		echo "  -c, --create     Create a cluster-file with the given name."
		echo "  -e, --edit       Edit the token (or cluster-file if given.)"
		echo "  -h, --help       Display this help message."
		echo "  -r, --rename     Rename a cluster file."
		echo "  -s, --search     List matching cluster files."
		echo "  -t, --token      Source the token."
		return 0
		;;
	create)
		if [ -z "$CLUSTER" ]; then
			>&2 echo "Name a cluster to create."
			return 1
		fi
		if [ -e "$SHOES_PATH/cluster/$CLUSTER.sh" ]; then
			>&2 echo "Cluster file already exists at $SHOES_PATH/cluster/$CLUSTER.sh"
			return 1
		fi
		>&2 echo "Editing cluster file at $SHOES_PATH/cluster/$CLUSTER.sh"
		vi "$SHOES_PATH/cluster/$CLUSTER.sh"
		return $?
		;;
	edit)
		if [ -n "$CLUSTER" ]; then
			if [ -e "$SHOES_PATH/cluster/$CLUSTER.sh" ]; then
				>&2 echo "Editing cluster file at $SHOES_PATH/cluster/$CLUSTER.sh"
				vi "$SHOES_PATH/cluster/$CLUSTER.sh"
				return $?
			fi
			>&2 echo "Cluster file does not exist at $SHOES_PATH/cluster/$CLUSTER.sh"
			return 1
		fi
		>&2 echo -n "Backing up token: "
		cp -v "$SHOES_PATH/_token.txt" "$SHOES_PATH/_token.txt.bak"
		>&2 echo "Editing token at $SHOES_PATH/_token.txt"
		>&2 echo "If you want to source the token, run:"
		>&2 echo "  shoes -t"
		vi "$SHOES_PATH/_token.txt"
		return $?
		;;
	token)
		if [ -n "$CLUSTER" ]; then
			>&2 echo "Error: Do not specify a cluster when sourcing the token."
			return 1
		fi
		>&2 echo "Sourcing token from $SHOES_PATH/_token.txt"
		export VAULT_TOKEN=$(cat "$SHOES_PATH/_token.txt")
		return 0
		;;
	login)
		if [ -z "$CLUSTER" ]; then
			>&2 echo "Name a cluster to search for."
			return 1
		fi
		if [ -e "$SHOES_PATH/cluster/$CLUSTER.sh" ]; then
			>&2 echo "Sourcing cluster file at $SHOES_PATH/cluster/$CLUSTER.sh"
			source "$SHOES_PATH/cluster/$CLUSTER.sh"
			return $?
		fi
		;& # fall-through if no cluster file matches exactly
	search)
		if [ -z "$CLUSTER" ]; then
			CLUSTER=".*"
		fi
		local CLUSTER_LIST="$(ls $SHOES_PATH/cluster|grep -v ^_|awk -F. '{print $1}'|sort)"
		local MATCHES=$(grep $CLUSTER <<< $CLUSTER_LIST)
		local LENGTH=$(wc -l <<< $MATCHES|xargs)
		if [ "$MATCHES" = "" ]; then
			>&2 echo "Found 0 clusters matching \"$CLUSTER\""
			return 1
		elif [ "$LENGTH" -gt 1 ]; then
			ACTION="search"
		fi
		if [ "$ACTION" = "search" ]; then
			>&2 echo "Found $LENGTH matching clusters:"
			sed 's/^/  /' <<< $MATCHES|grep --color $CLUSTER
			return 0
		else
			>&2 echo "Sourcing cluster file at $SHOES_PATH/cluster/$MATCHES.sh"
			source "$SHOES_PATH/cluster/$MATCHES.sh"
		fi
		;;
	esac
}
##############################################################
# timestamp.sh
# Records lines of text along with a timestamp. Use with a -
# to add a note to the last timestamp, or with --all to see
# with notes.
##############################################################

function ts() {
	local STAMP="$(date -u '+%y%m%d.%H%MZ')"
	local TXT="timestamps.txt"
	if [ -z "$1" ]; then
		if [ -e $TXT ]; then
			grep --color '^\d\S*' <(cat $TXT; echo "$STAMP <<< Current time.")
		else
			echo "$STAMP <<< Current time."|grep --color '^\S*' 
		fi
	elif [[ "$@" = "--help" ]]; then
		echo "Usage: ts [OPTIONS] [MESSAGE]"
		echo "Record a message to timestamps.txt along with a timestamp."
		echo 
		echo "  -                Add a note to the last timestamp."
		echo "  --all            Show all timestamps with notes."
		echo
	elif [[ "$@" = "--all" ]]; then
		grep --color '^\S*' <(cat $TXT; echo "$STAMP <<< Current time.")
	elif [[ "$@" = "-" ]]; then
		grep '^\d' $TXT|tail -n1|grep --color '^\S*'
		echo "Enter notes:"|grep --color '.*'
		sed 's/^/  /' >> $TXT
		echo "Use \"ts --all\" to see notes."|grep --color '.*'
	else
		echo "$STAMP $@"|tee -a $TXT|grep --color '^\S*'
	fi
}

function tsl() {
	ts|sed 's/Z/+0000/'|while read line; do
		local GIVEN_STAMP="$(awk '{print $1}' <<< $line)"
		local CONVERTED_STAMP="$(date -j -f '%y%m%d.%H%M%z' $GIVEN_STAMP '+%y%m%d.%H%M%z')"
		sed "s/$GIVEN_STAMP/$CONVERTED_STAMP/" <<< $line
	done|grep --color '^\S*'
}

##############################################################
# workspace.sh
# Quickly create/search/switch-to project directories. Run
# with any term to search existing workspaces (or to switch to
# that workspace if only one is matched.) Use -d to sort by
# timestamp or -c to create a new workspace.
##############################################################

function workspace() {
    local WORKSPACE_ROOT=~/workspaces
    local ACTION=""
    local ORDER="name"
    local LABEL=""
    case $1 in
        -c|--create)
            ACTION="create"
            LABEL="$2"
            ;;
        -h|--help)
            ACTION="help"
            ;;
        -d|--date)
            ORDER="date"
            ACTION="goto"
            LABEL="$2"
            ;;
        *)
            ACTION="goto"
            LABEL="$1"
            ;;
    esac
    case $ACTION in
        help)
            echo "Usage: workspace [OPTIONS] <LABEL>"
            echo "Switch to a workspace with the given label. Or, if an option is given:"
            echo
            echo "  -c, --create     Create a workspace with the given label."
            echo "  -h, --help       Display this help message."
			echo
			echo "If no argument is given, switch to the latest workspace."
            return 0
        ;;
        create)
            if [ -z "$LABEL" ]; then
                >&2 echo "Provide a label to create a workspace."
                return 1
            fi
            local TIMESTAMP="$(date '+%y%m%d')"
            local WORKSPACE_PATH="$WORKSPACE_ROOT/$LABEL.$TIMESTAMP"
            if [ -e "$WORKSPACE_PATH" ]; then
                >&2 echo "Workspace already exists at $WORKSPACE_PATH"
                return 1
            fi
            >&2 mkdir -p "$WORKSPACE_PATH"
            >&2 echo "Leaving $PWD"
            cd "$WORKSPACE_PATH"
            return $?
        ;;
        *)
            if [ -z "$LABEL" ]; then
                >&2 echo "Leaving $PWD"
                cd $(ls -td ~/workspaces/*|head -n1)
                return 0
            fi
            local WORKSPACES=$(ls -td $WORKSPACE_ROOT/*|awk -F/ '{print $NF}')
            if [ "$ORDER" = "date" ]; then
                local WORKSPACE_LIST=$(awk -F. '{print $2,$0}'<<<$WORKSPACES|sort -n|awk '{print $2}')
            else
                local WORKSPACE_LIST=$(sort<<<$WORKSPACES)
            fi
            if ! grep -q $LABEL <<< $WORKSPACE_LIST; then
                >&2 echo "Found 0 workspaces matching \"$LABEL\""
                return 1
            else
                local MATCHES=$(grep --color $LABEL <<< $WORKSPACE_LIST)
                if [ $(wc -l <<< $MATCHES|xargs) -eq 1 ]; then
                    >&2 echo "Leaving $PWD"
                    cd "$WORKSPACE_ROOT/$MATCHES"
                else
                    >&2 echo "Found $(wc -l <<< $MATCHES|xargs) matching workspaces:"
                    sed 's/^/  /' <<< $MATCHES|grep --color $LABEL
                    return 1
                fi
            fi
            return $?
        ;;
    esac
}
